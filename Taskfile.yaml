version: '3'

vars:
  ENVTEST_K8S_VERSION: 1.30.0
  GO_VERSION: '1.22'
  GOBIN:
    sh: echo "${GOBIN:-$(go env GOPATH)/bin}"
  CONTAINER_TOOL: docker
  PLATFORMS: linux/arm64,linux/amd64,linux/s390x,linux/ppc64le
  LOCALBIN: '{{.ROOT_DIR}}/bin'
  KUBECTL: kubectl
  KUSTOMIZE_VERSION: v5.4.2
  CONTROLLER_TOOLS_VERSION: v0.16.0
  ENVTEST_VERSION: release-0.18
  GOLANGCI_LINT_VERSION: v1.57.2
  HELMIFY_VERSION: v0.4.13
  TEST_VERBOSITY: -v
  ENV: development
  LOG_LEVEL: info

  IGNORE_NOT_FOUND: '{{.IGNORE_NOT_FOUND | default "false"}}'
  USE_KIND_CONTEXT: '{{.USE_KIND_CONTEXT | default "true"}}'
  KIND_KUBECONFIG: '{{.KIND_KUBECONFIG | default "${HOME}/.kube/kind-config-test"}}'
  KIND_CONTEXT: '{{.KIND_CONTEXT | default "kind-test"}}'
  KIND_CLUSTER_NAME: '{{.KIND_CLUSTER_NAME | default "test"}}'
  IMG: '{{.IMG | default "controller:latest"}}'

tasks:
  default:
    cmds:
      - task: list
  
  list:
    desc: Display all available tasks
    cmds:
      - task --list

  #### TOOLS ####
  ensure-dir:
    internal: true
    desc: Ensure the local bin directory exists
    cmds:
      - mkdir -p {{.LOCALBIN}}

  kustomize:
    desc: Download kustomize locally if necessary
    deps: [ensure-dir]
    cmds:
      - go install sigs.k8s.io/kustomize/kustomize/v5@{{.KUSTOMIZE_VERSION}}
      - mv {{.GOBIN}}/kustomize {{.LOCALBIN}}/kustomize-{{.KUSTOMIZE_VERSION}}

  controller-gen:
    desc: Download controller-gen locally if necessary and create/update symlink
    deps: [ensure-dir]
    cmds:
      - |
        if [ ! -f {{.LOCALBIN}}/controller-gen-{{.CONTROLLER_TOOLS_VERSION}} ]; then
          echo "Downloading controller-gen {{.CONTROLLER_TOOLS_VERSION}}..."
          go install sigs.k8s.io/controller-tools/cmd/controller-gen@{{.CONTROLLER_TOOLS_VERSION}}
          mkdir -p {{.LOCALBIN}}
          mv $(go env GOPATH)/bin/controller-gen {{.LOCALBIN}}/controller-gen-{{.CONTROLLER_TOOLS_VERSION}}
        fi
      - ln -sf {{.LOCALBIN}}/controller-gen-{{.CONTROLLER_TOOLS_VERSION}} {{.LOCALBIN}}/controller-gen

  envtest:
    desc: Download setup-envtest locally if necessary
    deps: [ensure-dir]
    cmds:
      - go install sigs.k8s.io/controller-runtime/tools/setup-envtest@{{.ENVTEST_VERSION}}
      - mv {{.GOBIN}}/setup-envtest {{.LOCALBIN}}/setup-envtest-{{.ENVTEST_VERSION}}

  golangci-lint:
    desc: Download golangci-lint locally if necessary
    deps: [ensure-dir]
    cmds:
      - go install github.com/golangci/golangci-lint/cmd/golangci-lint@{{.GOLANGCI_LINT_VERSION}}
      - mv {{.GOBIN}}/golangci-lint {{.LOCALBIN}}/golangci-lint-{{.GOLANGCI_LINT_VERSION}}

  helmify:
    desc: Download helmify locally if necessary
    deps: [ensure-dir]
    cmds:
      - go install github.com/arttor/helmify/cmd/helmify@{{.HELMIFY_VERSION}}
      - mv {{.GOBIN}}/helmify {{.LOCALBIN}}/helmify-{{.HELMIFY_VERSION}}

  #### LINT ####
  fmt:
    desc: Run go fmt against code
    cmds:
      - go fmt ./...

  vet:
    desc: Run go vet against code
    cmds:
      - go vet ./...

  lint:
    desc: Run golangci-lint linter
    cmds:
      - '{{.LOCALBIN}}/golangci-lint run'
    deps:
      - golangci-lint

  lint-fix:
    desc: Run golangci-lint linter and perform fixes
    cmds:
      - '{{.LOCALBIN}}/golangci-lint run --fix'
    deps:
      - golangci-lint

  #### TESTS ####
  test-unit:
    desc: Run unit tests with coverage
    cmds:
      - rm -rf coverage
      - mkdir -p coverage
      - go test {{.TEST_VERBOSITY}} -tags=unit ./...
    deps:
      - manifests
      - generate
      - fmt
      - vet

  test-integration:
    desc: Run integration tests with coverage
    cmds:
      - rm -rf coverage
      - mkdir -p coverage
      - |
        KUBEBUILDER_ASSETS="$({{.LOCALBIN}}/setup-envtest-{{.ENVTEST_VERSION}} use {{.ENVTEST_K8S_VERSION}} --bin-dir {{.LOCALBIN}} -p path)" \
        go test {{.TEST_VERBOSITY}} ./test/integration/...
    deps:
      - manifests
      - generate
      - fmt
      - vet
      - envtest

  test-e2e:
    desc: Run end-to-end tests with Kind cluster
    cmds:
      - go test {{.TEST_VERBOSITY}} -tags=e2e ./test/e2e/...
      - task: kind-delete-cluster
    deps:
      - manifests
      - generate
      - fmt
      - vet
      - docker-build
      - kind-create-cluster
      - kind-load-image

  test-all:
    desc: Run all tests
    cmds:
      - task: test-unit
      - task: test-integration
      - task: test-e2e
      - echo "All tests completed"

  coverage-report:
    desc: Generate a combined coverage report
    cmds:
      - mkdir -p coverage
      - echo "mode set" > coverage/coverage.out
      - tail -q -n +2 coverage/*.out >> coverage/coverage.out
      - go tool cover -html=coverage/coverage.out -o coverage/coverage.html
      - go tool cover -func=coverage/coverage.out
      - echo "Combined test coverage report generated at coverage/coverage.html"
    deps:
      - test-unit
      - test-integration

  #### CLUSTER ####
  use-kind-context:
    internal: true
    cmds:
      - kubectl config use-context {{.KIND_CONTEXT}}

  kind-ensure:
    desc: Ensure a Kind cluster exists, creating it if necessary
    cmds:
      - |
        if ! kind get clusters | grep -q '^{{.KIND_CLUSTER_NAME}}$'; then
          echo "Creating Kind cluster '{{.KIND_CLUSTER_NAME}}'..."
          kind create cluster --name {{.KIND_CLUSTER_NAME}} --image kindest/node:v{{.ENVTEST_K8S_VERSION}}
        else
          echo "Kind cluster '{{.KIND_CLUSTER_NAME}}' already exists."
        fi
      - task: use-kind-context

  kind-create:
    desc: Create a Kind cluster
    cmds:
      - kind create cluster --name {{.KIND_CLUSTER_NAME}} --image kindest/node:v{{.ENVTEST_K8S_VERSION}}
      - task: use-kind-context

  kind-delete:
    desc: Delete the Kind cluster
    cmds:
      - kind delete cluster --name {{.KIND_CLUSTER_NAME}}

  kind-stop:
    desc: Stop the Kind cluster
    cmds:
      - docker stop test-control-plane || true

  kind-start:
    desc: Start the Kind cluster
    cmds:
      - docker start test-control-plane || true

  kind-load-image:
    cmds:
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          echo "Using Kind context..."
          kind load docker-image {{.IMG}} --name {{.KIND_CLUSTER_NAME}}
        else
          echo "Skipping image load for non-Kind context"
        fi
    deps:
      - docker-build

  kind-load-images:
    desc: Load internal and external Docker images into Kind cluster
    vars:
      INT_IMAGES_TO_LOAD: 
        sh: echo {{.IMG}}
      EXT_IMAGES_TO_LOAD: 
        - envoyproxy/envoy:v1.31-latest
        - linuxserver/code-server:latest
        - linuxserver/webtop:debian-xfce
    cmds:
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          echo "Using Kind context..."
          for img in {{.INT_IMAGES_TO_LOAD}}; do
            echo "Loading $img";
            kind load docker-image $img --name {{.KIND_CLUSTER_NAME}};
          done
          for img in {{range .EXT_IMAGES_TO_LOAD}}"{{.}}" {{end}}; do
            echo "Pulling $img";
            {{.CONTAINER_TOOL}} pull $img;
            echo "Loading $img";
            kind load docker-image $img --name {{.KIND_CLUSTER_NAME}};
          done
        else
          echo "Skipping image load for non-Kind context"
        fi
    deps:
      - docker-build

  #### HELM BUILD & PACKAGE ####
  helm-package-kode-crd:
    desc: Build and package kode-crd Helm chart
    deps: [manifests, generate, helmify]
    vars:
      VERSION: '{{.CLI_ARGS | default "v0.0.0-latest"}}'
    cmds:
      - echo "Building kode-crd chart from config/crd..."
      - '{{.LOCALBIN}}/kustomize-{{.KUSTOMIZE_VERSION}} build config/crd | {{.LOCALBIN}}/helmify-{{.HELMIFY_VERSION}} helm-charts/kode-crd'
      - echo "Packaging kode-crd chart version {{.VERSION}}..."
      - mkdir -p /tmp/helm-charts/kode-crd
      - cp -r helm-charts/kode-crd/* /tmp/helm-charts/kode-crd/
      - sed -i "s/v0.0.0-latest/{{.VERSION}}/g" /tmp/helm-charts/kode-crd/Chart.yaml
      - sed -i "s/v0.0.0-latest/{{.VERSION}}/g" /tmp/helm-charts/kode-crd/README.md
      - sed -i "s/v0.0.0--latest/{{.VERSION}}/g" /tmp/helm-charts/kode-crd/README.md # Special case for the img.shields.io badge
      - helm package /tmp/helm-charts/kode-crd --version {{.VERSION}} --destination /tmp
      - mv /tmp/kode-crd-{{.VERSION}}.tgz ./kode-crd-{{.VERSION}}.tgz
      - rm -rf /tmp/helm-charts/kode-crd

  helm-package-kode:
    desc: Build and package kode Helm chart
    deps: [manifests, generate, helmify]
    vars:
      VERSION: '{{.CLI_ARGS | default "v0.0.0-latest"}}'
    cmds:
      - echo "Building kode chart from config/crd..."
      - '{{.LOCALBIN}}/kustomize-{{.KUSTOMIZE_VERSION}} build config/default | {{.LOCALBIN}}/helmify-{{.HELMIFY_VERSION}}  -generate-defaults -image-pull-secrets helm-charts/kode'
      - echo "Packaging kode chart version {{.VERSION}}..."
      - mkdir -p /tmp/helm-charts/kode
      - cp -r helm-charts/kode/* /tmp/helm-charts/kode/
      - sed -i "s/v0.0.0-latest/{{.VERSION}}/g" /tmp/helm-charts/kode/Chart.yaml
      - sed -i "s/v0.0.0-latest/{{.VERSION}}/g" /tmp/helm-charts/kode/values.yaml
      - sed -i "s/v0.0.0-latest/{{.VERSION}}/g" /tmp/helm-charts/kode/README.md
      - sed -i "s/v0.0.0--latest/{{.VERSION}}/g" /tmp/helm-charts/kode/README.md # Special case for the img.shields.io badge
      - helm package /tmp/helm-charts/kode --version {{.VERSION}} --destination /tmp
      - mv /tmp/kode-{{.VERSION}}.tgz ./kode-{{.VERSION}}.tgz
      - rm -rf /tmp/helm-charts/kode

  helm-package:
    desc: Build and package all Helm charts
    vars:
      VERSION: '{{.CLI_ARGS | default "v0.0.0-latest"}}'
    cmds:
      - task: helm-package-kode-crd
        vars: { VERSION: '{{.VERSION}}' }
      - task: helm-package-kode
        vars: { VERSION: '{{.VERSION}}' }

  helm-manage-kode-crd:
    desc: Install or uninstall kode-crd Helm chart on the cluster
    vars:
      RELEASE_NAME: 'kode-crd'
      NAMESPACE: 'kode-system'
      VERSION: '{{.VERSION | default "v0.0.0-latest"}}'
      ACTION: '{{.ACTION | default "install"}}'
    cmds:
      - |
        if [ "{{.ACTION}}" = "install" ]; then
          echo "Installing/upgrading kode-crd chart version {{.VERSION}} onto the cluster..."
          helm upgrade --install {{.RELEASE_NAME}} ./kode-crd-{{.VERSION}}.tgz \
            --namespace {{.NAMESPACE}} \
            --create-namespace \
            --wait \
            --timeout 5m
          echo "kode-crd chart version {{.VERSION}} installed/upgraded successfully as release {{.RELEASE_NAME}} in namespace {{.NAMESPACE}}"
        elif [ "{{.ACTION}}" = "uninstall" ]; then
          echo "Uninstalling kode-crd chart release {{.RELEASE_NAME}} from namespace {{.NAMESPACE}}..."
          helm uninstall {{.RELEASE_NAME}} --namespace {{.NAMESPACE}} || true
          echo "kode-crd chart release {{.RELEASE_NAME}} uninstalled from namespace {{.NAMESPACE}}"
        else
          echo "Invalid ACTION: {{.ACTION}}. Use 'install' or 'uninstall'."
          exit 1
        fi
    preconditions:
      - sh: '[ "{{.ACTION}}" = "uninstall" ] || test -f ./kode-crd-{{.VERSION}}.tgz'
        msg: "Chart package kode-crd-{{.VERSION}}.tgz not found. Please run 'task helm-package-kode-crd' first."

  helm-manage-kode:
    desc: Install or uninstall kode Helm chart on the cluster
    vars:
      RELEASE_NAME: 'kode'
      NAMESPACE: 'kode-system'
      VERSION: '{{.VERSION | default "v0.0.0-latest"}}'
      ACTION: '{{.ACTION | default "install"}}'
      CONTROLLER_IMAGE_TAG: 'dev-latest'
    cmds:
      - |
        if [ "{{.ACTION}}" = "install" ]; then
          echo "Installing/upgrading kode chart version {{.VERSION}} onto the cluster..."
          helm upgrade --install {{.RELEASE_NAME}} ./kode-{{.VERSION}}.tgz \
            --namespace {{.NAMESPACE}} \
            --create-namespace \
            --set controllerManager.manager.image.tag={{.CONTROLLER_IMAGE_TAG}} \
            --wait \
            --timeout 5m
          echo "kode chart version {{.VERSION}} installed/upgraded successfully as release {{.RELEASE_NAME}} in namespace {{.NAMESPACE}} with controller image tag {{.CONTROLLER_IMAGE_TAG}}"
        elif [ "{{.ACTION}}" = "uninstall" ]; then
          echo "Uninstalling kode chart release {{.RELEASE_NAME}} from namespace {{.NAMESPACE}}..."
          helm uninstall {{.RELEASE_NAME}} --namespace {{.NAMESPACE}} || true
          echo "kode chart release {{.RELEASE_NAME}} uninstalled from namespace {{.NAMESPACE}}"
        else
          echo "Invalid ACTION: {{.ACTION}}. Use 'install' or 'uninstall'."
          exit 1
        fi
    preconditions:
      - sh: '[ "{{.ACTION}}" = "uninstall" ] || test -f ./kode-{{.VERSION}}.tgz'
        msg: "Chart package kode-{{.VERSION}}.tgz not found. Please run 'task helm-package-kode' first."

  helm-manage:
    desc: Install or uninstall all kode Helm charts on the cluster
    vars:
      NAMESPACE: 'kode-system'
      VERSION: '{{.VERSION | default "v0.0.0-latest"}}'
      ACTION: '{{.ACTION | default "install"}}'
    cmds:
      - task: helm-manage-kode-crd
        vars:
          NAMESPACE: '{{.NAMESPACE}}'
          VERSION: '{{.VERSION}}'
          ACTION: '{{.ACTION}}'
      - task: helm-manage-kode
        vars:
          NAMESPACE: '{{.NAMESPACE}}'
          VERSION: '{{.VERSION}}'
          ACTION: '{{.ACTION}}'

  #### DOCKER BUILD ####
  manifests:
    desc: Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects
    cmds:
      - '{{.LOCALBIN}}/controller-gen-{{.CONTROLLER_TOOLS_VERSION}} rbac:roleName=manager-role crd webhook paths="./..." output:crd:artifacts:config=config/crd/bases'
    deps:
      - controller-gen

  generate:
    desc: Generate code containing DeepCopy, DeepCopyInto, and DeepCopyObject method implementations
    cmds:
      - '{{.LOCALBIN}}/controller-gen-{{.CONTROLLER_TOOLS_VERSION}} object:headerFile="hack/boilerplate.go.txt" paths="./..."'
    deps:
      - controller-gen

  build:
    desc: Build manager binary
    cmds:
      - go build -o bin/manager cmd/main.go
    deps:
      - manifests
      - generate
      - fmt
      - vet

  build-installer:
    desc: Generate a consolidated YAML with CRDs and deployment
    cmds:
      - mkdir -p dist
      - cd config/manager && {{.LOCALBIN}}/kustomize edit set image controller={{.IMG}}
      - '{{.LOCALBIN}}/kustomize-{{.KUSTOMIZE_VERSION}} build config/default > dist/install.yaml'
    deps:
      - manifests
      - generate
      - kustomize

  docker-build-local:
    desc: Build docker image locally
    cmds:
      - '{{.CONTAINER_TOOL}} build -t {{.IMG}} .'

  docker-push-if-needed:
    desc: Push docker image if not using a local cluster
    cmds:
      - |
        if [ "{{.USE_KIND_CONTEXT}}" != "true" ] && [ "{{.CLUSTER_TYPE}}" != "minikube" ]; then
          echo "Pushing image to registry..."
          {{.CONTAINER_TOOL}} push {{.IMG}}
        else
          echo "Skipping push for local cluster"
        fi

  load-image-to-cluster:
    desc: Load the locally built image into the Kind cluster
    cmds:
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          echo "Loading image into Kind cluster..."
          kind load docker-image {{.IMG}} --name {{.KIND_CLUSTER_NAME}}
        else
          echo "Skipping image load for non-Kind cluster"
        fi

  docker-buildx:
    desc: Build docker image for the manager with cross-platform support
    cmds:
      - |
        BUILDER_NAME="project-v3-builder"
        if ! {{.CONTAINER_TOOL}} buildx inspect $BUILDER_NAME > /dev/null 2>&1; then
          {{.CONTAINER_TOOL}} buildx create --name $BUILDER_NAME --use
        else
          {{.CONTAINER_TOOL}} buildx use $BUILDER_NAME
        fi
      - |
        if [ "{{.PUSH}}" = "true" ]; then
          echo "Building and pushing multi-platform image..."
          {{.CONTAINER_TOOL}} buildx build --platform={{.PLATFORMS}} --tag {{.IMG}} --build-arg BUILDPLATFORM={{.BUILDPLATFORM}} --push .
        elif [ "{{.LOAD}}" = "true" ]; then
          echo "Building and loading images for each platform..."
          IFS=',' read -ra PLATFORM_ARRAY <<< "{{.PLATFORMS}}"
          for PLATFORM in "${PLATFORM_ARRAY[@]}"; do
            echo "Building for $PLATFORM..."
            {{.CONTAINER_TOOL}} buildx build --platform=$PLATFORM --tag {{.IMG}}-$PLATFORM --build-arg BUILDPLATFORM={{.BUILDPLATFORM}} --load .
          done
        else
          echo "Building multi-platform image without pushing..."
          {{.CONTAINER_TOOL}} buildx build --platform={{.PLATFORMS}} --tag {{.IMG}} --build-arg BUILDPLATFORM={{.BUILDPLATFORM}} .
        fi
    vars:
      PUSH: '{{.PUSH | default "false"}}'
      LOAD: '{{.LOAD | default "false"}}'
      PLATFORMS: '{{.PLATFORMS | default "linux/arm64,linux/amd64,linux/s390x,linux/ppc64le"}}'
      BUILDPLATFORM: '{{.BUILDPLATFORM | default "${BUILDPLATFORM}"}}'

  docker-push:
    desc: Push docker image with the manager
    cmds:
      - '{{.CONTAINER_TOOL}} push {{.IMG}}'

  #### DEVELOPMENT ####
  create-dev-cert:
    desc: Create a development certificate for Envoy Gateway if it doesn't exist
    cmds:
      - mkdir -p {{.ROOT_DIR}}/hack/certs
      - |
        if [ ! -f {{.ROOT_DIR}}/hack/certs/example.com.crt ] || [ ! -f {{.ROOT_DIR}}/hack/certs/example.com.key ]; then
          echo "Certificate files don't exist. Creating new certificate..."
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout {{.ROOT_DIR}}/hack/certs/example.com.key -out {{.ROOT_DIR}}/hack/certs/example.com.crt -subj "/CN=*.example.com"
        else
          echo "Certificate files already exist. Skipping creation."
        fi
      - |
        cat <<EOF > {{.ROOT_DIR}}/hack/certs/example-com-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: example-com
          namespace: default
        type: kubernetes.io/tls
        data:
          tls.crt: $(base64 -w 0 < {{.ROOT_DIR}}/hack/certs/example.com.crt)
          tls.key: $(base64 -w 0 < {{.ROOT_DIR}}/hack/certs/example.com.key)
        EOF
      - echo "Certificate and Secret YAML created/updated in {{.ROOT_DIR}}/hack/certs/"
    silent: true

  apply-dev-cert:
    desc: Apply the development certificate secret to the Kubernetes cluster
    deps:
      - create-dev-cert
    cmds:
      - kubectl apply -f {{.ROOT_DIR}}/hack/certs/example-com-secret.yaml

  deploy-flux:
    desc: Install Flux
    cmds:
      - timoni bundle apply -f ./hack/development/bundle.cue

  undeploy-flux:
    desc: Uninstall Flux
    cmds:
      - timoni bundle delete -f ./hack/development/bundle.cue

  deploy-tf-controller:
    desc: Install the tf-controller
    cmds:
      - kubectl apply -f ./hack/development/tf-controller.yaml

  undeploy-tf-controller:
    desc: Uninstall the tf-controller
    cmds:
      - kubectl delete -f ./hack/development/tf-controller.yaml

  deploy-envoy-gateway:
    desc: Install Envoy Gateway using Helm from OCI registry
    cmds:
      - |
        helm upgrade --install eg oci://docker.io/envoyproxy/gateway-helm \
          --version {{.ENVOY_GATEWAY_VERSION}} \
          -n {{.ENVOY_GATEWAY_NAMESPACE}} \
          --create-namespace \
          {{.ENVOY_GATEWAY_EXTRA_ARGS}}
    vars:
      ENVOY_GATEWAY_VERSION: 'v0.0.0-latest'
      ENVOY_GATEWAY_NAMESPACE: 'envoy-gateway-system'
      ENVOY_GATEWAY_EXTRA_ARGS: ''

  undeploy-envoy-gateway:
    desc: Uninstall Envoy Gateway
    cmds:
      - helm uninstall eg -n {{.ENVOY_GATEWAY_NAMESPACE}}
      - kubectl delete namespace {{.ENVOY_GATEWAY_NAMESPACE}} --ignore-not-found
    vars:
      ENVOY_GATEWAY_NAMESPACE: 'envoy-gateway-system'

  deploy-eg:
    desc: Deploy Envoy Gateway
    deps:
      - apply-dev-cert
      - deploy-envoy-gateway
    cmds:
      - kubectl apply -f ./hack/development/eg.yaml -n default

  undeploy-eg:
    desc: Undeploy Envoy Gateway
    cmds:
      - kubectl delete -f ./hack/development/eg.yaml -n default

  run:
    desc: Run a controller from your host
    vars:
      LOG_LEVEL: 'debug'
    cmds:
      - '{{.LOCALBIN}}/controller-gen rbac:roleName=manager-role crd webhook paths="./..." output:crd:artifacts:config=config/crd/bases'
      - |
        LOG_LEVEL_ARG="{{if .LOG_LEVEL}}{{.LOG_LEVEL}}{{else}}debug{{end}}"
        ENV={{.ENV}} go run ./cmd/main.go --log-level $LOG_LEVEL_ARG {{.CLI_ARGS}} 2>&1 | tee output.log
    deps:
      - controller-gen
      - manifests
      - generate
      - fmt
      - vet
      - install

  install:
    desc: Install CRDs into the cluster (Kind by default, or existing kubecontext)
    deps:
      - manifests
      - kustomize
    cmds:
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          echo "Using Kind context..."
          KUBECONFIG_ORIGINAL=$KUBECONFIG
          export KUBECONFIG="${KUBECONFIG}:{{.KIND_KUBECONFIG}}"
        else
          echo "Using existing kubecontext..."
        fi
      - '{{.LOCALBIN}}/kustomize-{{.KUSTOMIZE_VERSION}} build config/crd | {{.KUBECTL}} {{if eq .USE_KIND_CONTEXT "true"}}--context={{.KIND_CONTEXT}}{{end}} apply -f -'
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          export KUBECONFIG=$KUBECONFIG_ORIGINAL
        fi
    vars:
      USE_KIND_CONTEXT: '{{.USE_KIND_CONTEXT | default "true"}}'
      KIND_KUBECONFIG: '{{.KIND_KUBECONFIG | default "${HOME}/.kube/kind-config-test"}}'
      KIND_CONTEXT: '{{.KIND_CONTEXT | default "kind-test"}}'

  uninstall:
    desc: Uninstall CRDs from the cluster (Kind by default, or existing kubecontext)
    deps:
      - manifests
      - kustomize
    cmds:
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          echo "Using Kind context..."
          KUBECONFIG_ORIGINAL=$KUBECONFIG
          export KUBECONFIG="${KUBECONFIG}:{{.KIND_KUBECONFIG}}"
        else
          echo "Using existing kubecontext..."
        fi
      - '{{.LOCALBIN}}/kustomize-{{.KUSTOMIZE_VERSION}} build config/crd | {{.KUBECTL}} {{if eq .USE_KIND_CONTEXT "true"}}--context={{.KIND_CONTEXT}}{{end}} delete --ignore-not-found={{.IGNORE_NOT_FOUND}} -f -'
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          export KUBECONFIG=$KUBECONFIG_ORIGINAL
        fi
    vars:
      USE_KIND_CONTEXT: '{{.USE_KIND_CONTEXT | default "true"}}'
      KIND_KUBECONFIG: '{{.KIND_KUBECONFIG | default "${HOME}/.kube/kind-config-test"}}'
      KIND_CONTEXT: '{{.KIND_CONTEXT | default "kind-test"}}'
      IGNORE_NOT_FOUND: '{{.IGNORE_NOT_FOUND | default "false"}}'

  deploy:
    desc: Deploy controller to the specified cluster (Kind or remote)
    deps:
      - build-installer
    cmds:
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          echo "Using Kind cluster..."
          task: docker-build-local
          task: load-image-to-cluster
          KUBECONFIG_ORIGINAL=$KUBECONFIG
          export KUBECONFIG="${KUBECONFIG}:{{.KIND_KUBECONFIG}}"
        else
          echo "Using remote cluster. Ensure the image is built and pushed by the GitHub workflow."
        fi
      - task: install
      - |
        # Update the image in the deployment YAML
        sed -i 's|image: .*controller:.*|image: {{.IMG}}|' dist/install.yaml
      - '{{.KUBECTL}} {{if eq .USE_KIND_CONTEXT "true"}}--context={{.KIND_CONTEXT}}{{end}} apply -f dist/install.yaml'
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          export KUBECONFIG=$KUBECONFIG_ORIGINAL
        fi

  undeploy:
    desc: Undeploy controller from the specified cluster
    deps:
      - build-installer
    cmds:
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          echo "Using Kind cluster..."
          KUBECONFIG_ORIGINAL=$KUBECONFIG
          export KUBECONFIG="${KUBECONFIG}:{{.KIND_KUBECONFIG}}"
        else
          echo "Using remote cluster..."
        fi
      - '{{.KUBECTL}} {{if eq .USE_KIND_CONTEXT "true"}}--context={{.KIND_CONTEXT}}{{end}} delete --ignore-not-found={{.IGNORE_NOT_FOUND}} -f dist/install.yaml'
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          export KUBECONFIG=$KUBECONFIG_ORIGINAL
        fi
      - task: uninstall
    vars:
      IGNORE_NOT_FOUND: '{{.IGNORE_NOT_FOUND | default "false"}}'

  ### SAMPLES ###
  apply-samples:
    desc: Apply Kubernetes resources defined in config/samples/ to the cluster
    cmds:
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          echo "Using Kind context..."
          KUBECONFIG_ORIGINAL=$KUBECONFIG
          export KUBECONFIG="${KUBECONFIG}:{{.KIND_KUBECONFIG}}"
        else
          echo "Using existing kubecontext..."
        fi
      - '{{.KUBECTL}} {{if eq .USE_KIND_CONTEXT "true"}}--context={{.KIND_CONTEXT}}{{end}} apply -k config/samples/podtemplate/'
      - '{{.KUBECTL}} {{if eq .USE_KIND_CONTEXT "true"}}--context={{.KIND_CONTEXT}}{{end}} apply -k config/samples/entrypoint/'
      - '{{.KUBECTL}} {{if eq .USE_KIND_CONTEXT "true"}}--context={{.KIND_CONTEXT}}{{end}} apply -k config/samples/kode/'
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          export KUBECONFIG=$KUBECONFIG_ORIGINAL
        fi

  delete-samples:
    desc: Delete Kubernetes resources defined in config/samples/ from the cluster
    cmds:
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          echo "Using Kind context..."
          KUBECONFIG_ORIGINAL=$KUBECONFIG
          export KUBECONFIG="${KUBECONFIG}:{{.KIND_KUBECONFIG}}"
        else
          echo "Using existing kubecontext..."
        fi
      - '{{.KUBECTL}} {{if eq .USE_KIND_CONTEXT "true"}}--context={{.KIND_CONTEXT}}{{end}} delete -k config/samples/kode/'
      - '{{.KUBECTL}} {{if eq .USE_KIND_CONTEXT "true"}}--context={{.KIND_CONTEXT}}{{end}} delete -k config/samples/entrypoint/'
      - '{{.KUBECTL}} {{if eq .USE_KIND_CONTEXT "true"}}--context={{.KIND_CONTEXT}}{{end}} delete -k config/samples/podtemplate/'
      - |
        if [ "{{.USE_KIND_CONTEXT}}" = "true" ]; then
          export KUBECONFIG=$KUBECONFIG_ORIGINAL
        fi

  setup-dev:
    desc: Set up the complete development environment
    cmds:
      - task: kind-ensure
      - task: deploy-flux
      - task: deploy-envoy-gateway
      - task: deploy-eg
      - echo "Development environment is ready!"

  teardown-dev:
    desc: Tear down the complete development environment
    cmds:
      - task: kind-delete
      - echo "Development environment has been torn down."
