/*
Copyright 2024 Emil Larsson.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha2

import (
	"time"

	corev1 "k8s.io/api/core/v1"

	egv1alpha1 "github.com/envoyproxy/gateway/api/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	gwapiv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// EntryPointSpec defines the desired state of EntryPoint
type EntryPointSpec struct {
	// Type is the way the Kode resource is accessed. It could be subdomain or path.
	// +kubebuilder:validation:description=Type is the way the Kode resource is accessed. It could be subdomain or path.
	// +kubebuilder:validation:Optional
	// +kubebuilder:validation:Enum=subdomain;path
	RoutingType RoutingType `json:"routingType,omitempty" yaml:"routingType,omitempty"`

	// BaseDomain is the domain name to use either as a suffix in the case of Type=domain or as a prefix/domain in the case of Type=path.
	// When the type is domain, the controller will try to publish the Kode resource as a subdomain of the given domain (e.g <kode-resource>.kode.example.com).
	// When the type is path, the controller will try to publish the Kode resource as a path of the given BaseDomain (e.g kode.example.com/<kode-resource>).
	// +kubebuilder:validation:description=BaseDomain is the domain name to use either as a suffix in the case of Type=domain or as a prefix/domain in the case of Type=path. When the type is domain, the controller will try to publish the Kode resource as a subdomain of the given domain (e.g <kode-resource>.kode.example.com). When the type is path, the controller will try to publish the Kode resource as a path of the given BaseDomain (e.g kode.example.com/<kode-resource>).
	// +kubebuilder:validation:Optional
	BaseDomain BaseDomain `json:"baseDomain,omitempty" yaml:"baseDomain,omitempty"`

	// GatewaySpec defines the GatewaySpec for the EntryPoint. Only one of GatewaySpec or IngressSpec can be set.
	// +kubebuilder:validation:description=GatewaySpec defines the GatewaySpec for the EntryPoint. Only one of GatewaySpec or IngressSpec can be set.
	// +kubebuilder:validation:Optional
	GatewaySpec *GatewaySpec `json:"gatewaySpec,omitempty" yaml:"gatewaySpec,omitempty"`

	// AuthSpec defines the AuthSpec for the EntryPoint. Use this to influence the authentication and authorization policies of the EntryPoint.
	// +kubebuilder:validation:description=AuthSpec defines the AuthSpec for the EntryPoint. Use this to influence the authentication and authorization policies of the EntryPoint.
	// +kubebuilder:validation:Optional
	AuthSpec *AuthSpec `json:"authSpec,omitempty" yaml:"authSpec,omitempty"`
}

type GatewaySpec struct {
	// ExistingGatewayRef is a reference to an existing Gateway to use for the EntryPoint. Setting this will override everything else in GatewaySpec.
	// +kubebuilder:validation:description=ExistingGatewayRef is a reference to an existing Gateway to use for the EntryPoint. Setting this will override everything else in GatewaySpec.
	// +kubebuilder:validation:Optional
	ExistingGatewayRef CrossNamespaceObjectReference `json:"existingGatewayRef,omitempty" yaml:"existingGatewayRef,omitempty"`

	// GatewayClassName is the name of the GatewayClass to use for the Gateway.
	// +kubebuilder:validation:description=GatewayClassName is the name of the GatewayClass to use for the Gateway.
	// +kubebuilder:validation:Optional
	GatewayClassName gwapiv1.ObjectName `json:"gatewayClassName,omitempty" yaml:"gatewayClassName,omitempty"`

	// Certificate is a reference to a Secret containing the certificate and private key to use for the Gateway HTTPS Listener.
	// +kubebuilder:validation:description=Certificate is a reference to a Secret containing the certificate and private key to use for the Gateway HTTPS Listener.
	// +kubebuilder:validation:Optional
	Certificate []corev1.Secret `json:"certificates,omitempty" yaml:"certificates,omitempty"`

	// RouteSecurityPolicy defines the SecurityPolicies to apply to the HTTPRoute dynamically.
	// +kubebuilder:validation:description=RouteSecurityPolicy defines the SecurityPolicies to apply to the HTTPRoute dynamically.
	// +kubebuilder:validation:Optional
	RouteSecurityPolicy egv1alpha1.SecurityPolicy `json:"routeSecurityPolicy,omitempty" yaml:"routeSecurityPolicy,omitempty"`

	// EnvoyPatchPolicySpec defines the custom patch policy for the Envoy Proxy config generated by Envoy Gateway. For experienced users.
	// +kubebuilder:validation:description=EnvoyPatchPolicySpec defines the custom patch policy for the Envoy Proxy config generated by Envoy Gateway. For experienced users.
	// +kubebuilder:validation:Optional
	EnvoyPatchPolicySpec *egv1alpha1.EnvoyPatchPolicySpec `json:"envoyPatchPolicySpec,omitempty" yaml:"envoyPatchPolicySpec,omitempty"`
}

type AuthSpec struct {
	// AuthPolicy is the Envoy Gateway SecurityPolicy to use for the authentication. Can be either "none", "basicAuth", "jwt", "oidc", "extAuth" or "authorization". Find more info here: https://gateway.envoyproxy.io/contributions/design/security-policy/
	// +kubebuilder:validation:description=AuthPolicy is the Envoy Gateway SecurityPolicy to use for the authentication. Can be either "none", "basicAuth", "jwt", "oidc", "extAuth" or "authorization".
	// +kubebuilder:validation:Optional
	// +kubebuilder:validation:Enum=none;jwt;oidc;extAuth
	AuthPolicy string `json:"authPolicy,omitempty" yaml:"authPolicy,omitempty"`

	// IdentityPointer will influence what field is used to namespace the Kode resource. This is useful when using OIDC.
	IdentityPointer string `json:"identityPointer,omitempty" yaml:"identityPointer,omitempty"`
}

// EntryPointStatus defines the observed state of EntryPoint
type EntryPointStatus struct {
	BaseSharedStatus `json:",inline" yaml:",inline"`

	// Phase represents the current phase of the EntryPointPhase resource.
	Phase EntryPointPhase `json:"phase" yaml:"phase"`

	// LastError contains the last error message encountered during reconciliation.
	LastError string `json:"lastError,omitempty" yaml:"lastError,omitempty"`

	// LastErrorTime is the timestamp when the last error occurred.
	LastErrorTime *metav1.Time `json:"lastErrorTime,omitempty" yaml:"lastErrorTime,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// EntryPoint is the Schema for the entrypoints API
type EntryPoint struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   EntryPointSpec   `json:"spec,omitempty"`
	Status EntryPointStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// EntryPointList contains a list of EntryPoint
type EntryPointList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []EntryPoint `json:"items"`
}

// EntryPointPhase defines the phase of the EntryPoint
type EntryPointPhase string

const (
	// EntryPointPhaseCreating means the EntryPoint is being created.
	EntryPointPhaseCreating EntryPointPhase = "Creating"

	// KodePhaseCreated indicates that the Kode resource has been created.
	EntryPointPhaseCreated EntryPointPhase = "Created"

	// EntryPointPhaseFailed means the EntryPoint has failed.
	EntryPointPhaseFailed EntryPointPhase = "Failed"

	// EntryPointPhasePending means the EntryPoint is pending.
	EntryPointPhasePending EntryPointPhase = "Pending"

	// EntryPointPhaseActive means the EntryPoint is active.
	EntryPointPhaseActive EntryPointPhase = "Active"
)

type BaseDomain string

type RoutingType string

const (
	RoutingTypeSubdomain RoutingType = "subdomain"
	RoutingTypePath      RoutingType = "path"
)

func init() {
	SchemeBuilder.Register(&EntryPoint{}, &EntryPointList{})
}

func (e *EntryPoint) IsActive() bool {
	return e.Status.Phase == EntryPointPhaseActive
}

func (e *EntryPoint) SetCondition(conditionType string, status metav1.ConditionStatus, reason, message string) {
	newCondition := metav1.Condition{
		Type:               conditionType,
		Status:             status,
		Reason:             reason,
		Message:            message,
		LastTransitionTime: metav1.NewTime(time.Now()),
	}

	for i, condition := range e.Status.Conditions {
		if condition.Type == conditionType {
			if condition.Status != status {
				e.Status.Conditions[i] = newCondition
			}
			return
		}
	}

	e.Status.Conditions = append(e.Status.Conditions, newCondition)
}

func (e *EntryPoint) GetCondition(conditionType string) *metav1.Condition {
	for _, condition := range e.Status.Conditions {
		if condition.Type == conditionType {
			return &condition
		}
	}
	return nil
}

func (e *EntryPoint) IsSubdomainRouting() bool {
	return e.Spec.RoutingType == RoutingTypeSubdomain
}

func (e *EntryPoint) IsPathRouting() bool {
	return e.Spec.RoutingType == RoutingTypePath
}

func (e *EntryPoint) HasExistingGateway() bool {
	return e.Spec.GatewaySpec != nil && e.Spec.GatewaySpec.ExistingGatewayRef.Name != ""
}
